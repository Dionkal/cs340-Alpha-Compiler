

Terminals which are not used:

   GREATER
   LESS


Conflict in state 48 between rule 32 and token AND resolved as shift.
Conflict in state 48 between rule 32 and token OR resolved as shift.
Conflict in state 48 between rule 32 and token GREATEREQUAL resolved as shift.
Conflict in state 48 between rule 32 and token LESSEQUAL resolved as shift.
Conflict in state 48 between rule 32 and token EQUAL resolved as shift.
Conflict in state 48 between rule 32 and token NOTEQUAL resolved as shift.
Conflict in state 48 between rule 32 and token '*' resolved as shift.
Conflict in state 48 between rule 32 and token '/' resolved as shift.
Conflict in state 48 between rule 32 and token '%' resolved as shift.
Conflict in state 48 between rule 32 and token '+' resolved as shift.
Conflict in state 48 between rule 32 and token '-' resolved as shift.
Conflict in state 49 between rule 31 and token AND resolved as shift.
Conflict in state 49 between rule 31 and token OR resolved as shift.
Conflict in state 49 between rule 31 and token GREATEREQUAL resolved as shift.
Conflict in state 49 between rule 31 and token LESSEQUAL resolved as shift.
Conflict in state 49 between rule 31 and token EQUAL resolved as shift.
Conflict in state 49 between rule 31 and token NOTEQUAL resolved as shift.
Conflict in state 49 between rule 31 and token '*' resolved as shift.
Conflict in state 49 between rule 31 and token '/' resolved as shift.
Conflict in state 49 between rule 31 and token '%' resolved as shift.
Conflict in state 49 between rule 31 and token '+' resolved as shift.
Conflict in state 49 between rule 31 and token '-' resolved as shift.
Conflict in state 51 between rule 33 and token '(' resolved as reduce.
Conflict in state 51 between rule 33 and token '[' resolved as reduce.
Conflict in state 53 between rule 35 and token '(' resolved as reduce.
Conflict in state 53 between rule 35 and token '[' resolved as reduce.
Conflict in state 107 between rule 42 and token '(' resolved as reduce.
Conflict in state 115 between rule 38 and token AND resolved as reduce.
Conflict in state 115 between rule 38 and token OR resolved as reduce.
Conflict in state 115 between rule 38 and token GREATEREQUAL resolved as reduce.
Conflict in state 115 between rule 38 and token LESSEQUAL resolved as reduce.
Conflict in state 115 between rule 38 and token EQUAL resolved as reduce.
Conflict in state 115 between rule 38 and token NOTEQUAL resolved as reduce.
Conflict in state 115 between rule 38 and token '*' resolved as reduce.
Conflict in state 115 between rule 38 and token '/' resolved as reduce.
Conflict in state 115 between rule 38 and token '%' resolved as reduce.
Conflict in state 115 between rule 38 and token '+' resolved as reduce.
Conflict in state 115 between rule 38 and token '-' resolved as reduce.
Conflict in state 140 between rule 89 and token NOT resolved as shift.
Conflict in state 140 between rule 89 and token UMINUS resolved as shift.
Conflict in state 140 between rule 89 and token PLUSPLUS resolved as shift.
Conflict in state 140 between rule 89 and token MINUSMINUS resolved as shift.
Conflict in state 140 between rule 89 and token '(' resolved as reduce.
Conflict in state 140 between rule 89 and token '[' resolved as shift.
Conflict in state 159 between rule 90 and token NOT resolved as shift.
Conflict in state 159 between rule 90 and token UMINUS resolved as shift.
Conflict in state 159 between rule 90 and token PLUSPLUS resolved as shift.
Conflict in state 159 between rule 90 and token MINUSMINUS resolved as shift.
Conflict in state 159 between rule 90 and token '(' resolved as reduce.
Conflict in state 159 between rule 90 and token '[' resolved as shift.
State 0 contains 1 reduce/reduce conflict.
State 4 contains 1 reduce/reduce conflict.
State 5 contains 1 reduce/reduce conflict.
State 19 contains 15 shift/reduce conflicts and 1 reduce/reduce conflict.
State 20 contains 1 reduce/reduce conflict.
State 23 contains 15 shift/reduce conflicts and 1 reduce/reduce conflict.
State 25 contains 1 reduce/reduce conflict.
State 30 contains 4 shift/reduce conflicts.
State 32 contains 1 shift/reduce conflict.
State 47 contains 1 reduce/reduce conflict.
State 48 contains 3 shift/reduce conflicts and 1 reduce/reduce conflict.
State 49 contains 3 shift/reduce conflicts and 1 reduce/reduce conflict.
State 58 contains 1 reduce/reduce conflict.
State 59 contains 1 reduce/reduce conflict.
State 60 contains 1 reduce/reduce conflict.
State 61 contains 1 reduce/reduce conflict.
State 67 contains 1 shift/reduce conflict.
State 82 contains 1 reduce/reduce conflict.
State 83 contains 1 reduce/reduce conflict.
State 88 contains 1 reduce/reduce conflict.
State 89 contains 1 reduce/reduce conflict.
State 91 contains 1 reduce/reduce conflict.
State 95 contains 1 reduce/reduce conflict.
State 108 contains 1 reduce/reduce conflict.
State 110 contains 14 shift/reduce conflicts and 1 reduce/reduce conflict.
State 113 contains 1 shift/reduce conflict.
State 115 contains 3 shift/reduce conflicts and 1 reduce/reduce conflict.
State 122 contains 1 reduce/reduce conflict.
State 123 contains 1 reduce/reduce conflict.
State 124 contains 1 reduce/reduce conflict.
State 125 contains 1 reduce/reduce conflict.
State 127 contains 1 reduce/reduce conflict.
State 128 contains 1 reduce/reduce conflict.
State 137 contains 1 reduce/reduce conflict.
State 139 contains 24 shift/reduce conflicts and 2 reduce/reduce conflicts.
State 140 contains 17 shift/reduce conflicts and 2 reduce/reduce conflicts.
State 145 contains 1 reduce/reduce conflict.
State 147 contains 25 reduce/reduce conflicts.
State 148 contains 1 reduce/reduce conflict.
State 150 contains 1 reduce/reduce conflict.
State 153 contains 1 shift/reduce conflict.
State 155 contains 23 shift/reduce conflicts and 2 reduce/reduce conflicts.
State 158 contains 1 reduce/reduce conflict.
State 159 contains 17 shift/reduce conflicts and 2 reduce/reduce conflicts.

Grammar
rule 1    program -> stmt1
rule 2    stmt1 ->		/* empty */
rule 3    stmt1 -> stmt stmt1
rule 4    stmt -> expr ';'
rule 5    stmt -> ifstmt
rule 6    stmt -> whilestmt
rule 7    stmt -> forstmt
rule 8    stmt -> returnstmt
rule 9    stmt -> BREAK ';'
rule 10   stmt -> CONTINUE ';'
rule 11   stmt -> block
rule 12   stmt -> funcdef
rule 13   stmt -> ';'
rule 14   expr -> assignexpr
rule 15   expr -> expr op expr
rule 16   expr -> term
rule 17   op -> '+'
rule 18   op -> '-'
rule 19   op -> '*'
rule 20   op -> '/'
rule 21   op -> '%'
rule 22   op -> '>'
rule 23   op -> GREATEREQUAL
rule 24   op -> '<'
rule 25   op -> LESSEQUAL
rule 26   op -> EQUAL
rule 27   op -> NOTEQUAL
rule 28   op -> AND
rule 29   op -> OR
rule 30   term -> '(' expr ')'
rule 31   term -> UMINUS expr
rule 32   term -> NOT expr
rule 33   term -> PLUSPLUS lvalue
rule 34   term -> lvalue PLUSPLUS
rule 35   term -> MINUSMINUS lvalue
rule 36   term -> lvalue MINUSMINUS
rule 37   term -> primary
rule 38   assignexpr -> lvalue '=' expr
rule 39   primary -> lvalue
rule 40   primary -> call
rule 41   primary -> objectdef
rule 42   primary -> '(' funcdef ')'
rule 43   primary -> const
rule 44   lvalue -> ID
rule 45   lvalue -> LOCAL ID
rule 46   lvalue -> SCOPEOP ID
rule 47   lvalue -> member
rule 48   member -> lvalue '.' ID
rule 49   member -> lvalue '[' expr ']'
rule 50   member -> call '.' ID call '[' expr ']'
rule 51   call -> call '(' elist ')'
rule 52   call -> lvalue callsuffix
rule 53   call -> '(' funcdef ')' '(' elist ')'
rule 54   callsuffix -> normcall
rule 55   callsuffix -> methodcall
rule 56   normcall -> '(' elist ')'
rule 57   methodcall -> DOUPLEDOT ID '(' elist ')'
rule 58   elist ->		/* empty */
rule 59   elist -> expr elist1
rule 60   elist1 ->		/* empty */
rule 61   elist1 -> ',' expr elist1
rule 62   objectdef -> '['
rule 63   objectdef -> objectdef1 ']'
rule 64   objectdef1 ->		/* empty */
rule 65   objectdef1 -> elist
rule 66   objectdef1 -> indexed
rule 67   indexed ->		/* empty */
rule 68   indexed -> indexedelem indexed1
rule 69   indexed1 ->		/* empty */
rule 70   indexed1 -> ',' indexedelem indexed1
rule 71   indexedelem -> '{' expr ':' expr '}'
rule 72   block -> '{'
rule 73   block -> stmt1 '}'
rule 74   funcdef -> FUNCTION funcdef1 '(' idlist ')' block
rule 75   funcdef1 ->		/* empty */
rule 76   funcdef1 -> ID
rule 77   const -> NUMBER
rule 78   const -> STRING
rule 79   const -> NIL
rule 80   const -> TRUE
rule 81   const -> FALSE
rule 82   idlist ->		/* empty */
rule 83   idlist -> ID idlist1
rule 84   idlist1 ->		/* empty */
rule 85   idlist1 -> ',' ID idlist1
rule 86   ifstmt -> IF '(' expr ')' stmt ifstmt1
rule 87   ifstmt1 ->		/* empty */
rule 88   ifstmt1 -> ELSE stmt
rule 89   whilestmt -> WHILE '(' expr ')' stmt
rule 90   forstmt -> FOR '(' elist ';' expr ';' elist ')' stmt
rule 91   returnstmt -> RETURN returnstmt1
rule 92   returnstmt1 ->		/* empty */
rule 93   returnstmt1 -> expr

Terminals, with rules where they appear

$ (-1)
'%' (37) 21
'(' (40) 30 42 51 53 56 57 74 86 89 90
')' (41) 30 42 51 53 56 57 74 86 89 90
'*' (42) 19
'+' (43) 17
',' (44) 61 70 85
'-' (45) 18
'.' (46) 48 50
'/' (47) 20
':' (58) 71
';' (59) 4 9 10 13 90
'<' (60) 24
'=' (61) 38
'>' (62) 22
'[' (91) 49 50 62
']' (93) 49 50 63
'{' (123) 71 72
'}' (125) 71 73
error (256)
ID (258) 44 45 46 48 50 57 76 83 85
BREAK (259) 9
CONTINUE (260) 10
AND (261) 28
OR (262) 29
NOT (263) 32
GREATER (264)
GREATEREQUAL (265) 23
LESS (266)
LESSEQUAL (267) 25
EQUAL (268) 26
NOTEQUAL (269) 27
UMINUS (270) 31
PLUSPLUS (271) 33 34
MINUSMINUS (272) 35 36
LOCAL (273) 45
SCOPEOP (274) 46
DOUPLEDOT (275) 57
FUNCTION (276) 74
NUMBER (277) 77
STRING (278) 78
NIL (279) 79
TRUE (280) 80
FALSE (281) 81
IF (282) 86
ELSE (283) 88
WHILE (284) 89
FOR (285) 90
RETURN (286) 91

Nonterminals, with rules where they appear

program (50)
    on left: 1
stmt1 (51)
    on left: 2 3, on right: 1 3 73
stmt (52)
    on left: 4 5 6 7 8 9 10 11 12 13, on right: 3 86 88 89 90
expr (53)
    on left: 14 15 16, on right: 4 15 30 31 32 38 49 50 59 61 71 86
    89 90 93
op (54)
    on left: 17 18 19 20 21 22 23 24 25 26 27 28 29,
    on right: 15
term (55)
    on left: 30 31 32 33 34 35 36 37, on right: 16
assignexpr (56)
    on left: 38, on right: 14
primary (57)
    on left: 39 40 41 42 43, on right: 37
lvalue (58)
    on left: 44 45 46 47, on right: 33 34 35 36 38 39 48 49 52
member (59)
    on left: 48 49 50, on right: 47
call (60)
    on left: 51 52 53, on right: 40 50 51
callsuffix (61)
    on left: 54 55, on right: 52
normcall (62)
    on left: 56, on right: 54
methodcall (63)
    on left: 57, on right: 55
elist (64)
    on left: 58 59, on right: 51 53 56 57 65 90
elist1 (65)
    on left: 60 61, on right: 59 61
objectdef (66)
    on left: 62 63, on right: 41
objectdef1 (67)
    on left: 64 65 66, on right: 63
indexed (68)
    on left: 67 68, on right: 66
indexed1 (69)
    on left: 69 70, on right: 68 70
indexedelem (70)
    on left: 71, on right: 68 70
block (71)
    on left: 72 73, on right: 11 74
funcdef (72)
    on left: 74, on right: 12 42 53
funcdef1 (73)
    on left: 75 76, on right: 74
const (74)
    on left: 77 78 79 80 81, on right: 43
idlist (75)
    on left: 82 83, on right: 74
idlist1 (76)
    on left: 84 85, on right: 83 85
ifstmt (77)
    on left: 86, on right: 5
ifstmt1 (78)
    on left: 87 88, on right: 86
whilestmt (79)
    on left: 89, on right: 6
forstmt (80)
    on left: 90, on right: 7
returnstmt (81)
    on left: 91, on right: 8
returnstmt1 (82)
    on left: 92 93, on right: 91


state 0

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    '(' 	[reduce using rule 2 (stmt1)]
    $default	reduce using rule 2 (stmt1)

    program	go to state 160
    stmt1	go to state 24
    stmt	go to state 25
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 1

    lvalue  ->  ID .   (rule 44)

    $default	reduce using rule 44 (lvalue)



state 2

    stmt  ->  BREAK . ';'   (rule 9)

    ';' 	shift, and go to state 45



state 3

    stmt  ->  CONTINUE . ';'   (rule 10)

    ';' 	shift, and go to state 46



state 4

    term  ->  NOT . expr   (rule 32)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 48
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 5

    term  ->  UMINUS . expr   (rule 31)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 49
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 6

    term  ->  PLUSPLUS . lvalue   (rule 33)

    ID  	shift, and go to state 1
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    '(' 	shift, and go to state 50

    lvalue	go to state 51
    member	go to state 31
    call	go to state 52



state 7

    term  ->  MINUSMINUS . lvalue   (rule 35)

    ID  	shift, and go to state 1
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    '(' 	shift, and go to state 50

    lvalue	go to state 53
    member	go to state 31
    call	go to state 52



state 8

    lvalue  ->  LOCAL . ID   (rule 45)

    ID  	shift, and go to state 54



state 9

    lvalue  ->  SCOPEOP . ID   (rule 46)

    ID  	shift, and go to state 55



state 10

    funcdef  ->  FUNCTION . funcdef1 '(' idlist ')' block   (rule 74)

    ID  	shift, and go to state 56

    $default	reduce using rule 75 (funcdef1)

    funcdef1	go to state 57



state 11

    const  ->  NUMBER .   (rule 77)

    $default	reduce using rule 77 (const)



state 12

    const  ->  STRING .   (rule 78)

    $default	reduce using rule 78 (const)



state 13

    const  ->  NIL .   (rule 79)

    $default	reduce using rule 79 (const)



state 14

    const  ->  TRUE .   (rule 80)

    $default	reduce using rule 80 (const)



state 15

    const  ->  FALSE .   (rule 81)

    $default	reduce using rule 81 (const)



state 16

    ifstmt  ->  IF . '(' expr ')' stmt ifstmt1   (rule 86)

    '(' 	shift, and go to state 58



state 17

    whilestmt  ->  WHILE . '(' expr ')' stmt   (rule 89)

    '(' 	shift, and go to state 59



state 18

    forstmt  ->  FOR . '(' elist ';' expr ';' elist ')' stmt   (rule 90)

    '(' 	shift, and go to state 60



state 19

    returnstmt  ->  RETURN . returnstmt1   (rule 91)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    ID  	[reduce using rule 92 (returnstmt1)]
    NOT 	[reduce using rule 92 (returnstmt1)]
    UMINUS	[reduce using rule 92 (returnstmt1)]
    PLUSPLUS	[reduce using rule 92 (returnstmt1)]
    MINUSMINUS	[reduce using rule 92 (returnstmt1)]
    LOCAL	[reduce using rule 92 (returnstmt1)]
    SCOPEOP	[reduce using rule 92 (returnstmt1)]
    NUMBER	[reduce using rule 92 (returnstmt1)]
    STRING	[reduce using rule 92 (returnstmt1)]
    NIL 	[reduce using rule 92 (returnstmt1)]
    TRUE	[reduce using rule 92 (returnstmt1)]
    FALSE	[reduce using rule 92 (returnstmt1)]
    '(' 	[reduce using rule 92 (returnstmt1)]
    '{' 	[reduce using rule 92 (returnstmt1)]
    $default	reduce using rule 92 (returnstmt1)

    expr	go to state 61
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40
    returnstmt1	go to state 62



state 20

    term  ->  '(' . expr ')'   (rule 30)
    primary  ->  '(' . funcdef ')'   (rule 42)
    call  ->  '(' . funcdef ')' '(' elist ')'   (rule 53)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 63
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    funcdef	go to state 64
    const	go to state 40



state 21

    objectdef  ->  '[' .   (rule 62)

    $default	reduce using rule 62 (objectdef)



state 22

    stmt  ->  ';' .   (rule 13)

    $default	reduce using rule 13 (stmt)



state 23

    indexedelem  ->  '{' . expr ':' expr '}'   (rule 71)
    block  ->  '{' .   (rule 72)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    ID  	[reduce using rule 72 (block)]
    NOT 	[reduce using rule 72 (block)]
    UMINUS	[reduce using rule 72 (block)]
    PLUSPLUS	[reduce using rule 72 (block)]
    MINUSMINUS	[reduce using rule 72 (block)]
    LOCAL	[reduce using rule 72 (block)]
    SCOPEOP	[reduce using rule 72 (block)]
    NUMBER	[reduce using rule 72 (block)]
    STRING	[reduce using rule 72 (block)]
    NIL 	[reduce using rule 72 (block)]
    TRUE	[reduce using rule 72 (block)]
    FALSE	[reduce using rule 72 (block)]
    '(' 	[reduce using rule 72 (block)]
    '{' 	[reduce using rule 72 (block)]
    $default	reduce using rule 72 (block)

    expr	go to state 65
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 24

    program  ->  stmt1 .   (rule 1)
    block  ->  stmt1 . '}'   (rule 73)

    '}' 	shift, and go to state 66

    $default	reduce using rule 1 (program)



state 25

    stmt1  ->  stmt . stmt1   (rule 3)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    '(' 	[reduce using rule 2 (stmt1)]
    $default	reduce using rule 2 (stmt1)

    stmt1	go to state 67
    stmt	go to state 25
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 26

    stmt  ->  expr . ';'   (rule 4)
    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    ';' 	shift, and go to state 79
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 27

    expr  ->  term .   (rule 16)

    $default	reduce using rule 16 (expr)



state 28

    expr  ->  assignexpr .   (rule 14)

    $default	reduce using rule 14 (expr)



state 29

    term  ->  primary .   (rule 37)

    $default	reduce using rule 37 (term)



state 30

    term  ->  lvalue . PLUSPLUS   (rule 34)
    term  ->  lvalue . MINUSMINUS   (rule 36)
    assignexpr  ->  lvalue . '=' expr   (rule 38)
    primary  ->  lvalue .   (rule 39)
    member  ->  lvalue . '.' ID   (rule 48)
    member  ->  lvalue . '[' expr ']'   (rule 49)
    call  ->  lvalue . callsuffix   (rule 52)

    PLUSPLUS	shift, and go to state 85
    MINUSMINUS	shift, and go to state 86
    DOUPLEDOT	shift, and go to state 87
    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89
    '.' 	shift, and go to state 90
    '=' 	shift, and go to state 91

    PLUSPLUS	[reduce using rule 39 (primary)]
    MINUSMINUS	[reduce using rule 39 (primary)]
    '(' 	[reduce using rule 39 (primary)]
    '[' 	[reduce using rule 39 (primary)]
    $default	reduce using rule 39 (primary)

    callsuffix	go to state 92
    normcall	go to state 93
    methodcall	go to state 94



state 31

    lvalue  ->  member .   (rule 47)

    $default	reduce using rule 47 (lvalue)



state 32

    primary  ->  call .   (rule 40)
    member  ->  call . '.' ID call '[' expr ']'   (rule 50)
    call  ->  call . '(' elist ')'   (rule 51)

    '(' 	shift, and go to state 95
    '.' 	shift, and go to state 96

    '(' 	[reduce using rule 40 (primary)]
    $default	reduce using rule 40 (primary)



state 33

    objectdef1  ->  elist .   (rule 65)

    $default	reduce using rule 65 (objectdef1)



state 34

    primary  ->  objectdef .   (rule 41)

    $default	reduce using rule 41 (primary)



state 35

    objectdef  ->  objectdef1 . ']'   (rule 63)

    ']' 	shift, and go to state 97



state 36

    objectdef1  ->  indexed .   (rule 66)

    $default	reduce using rule 66 (objectdef1)



state 37

    indexed  ->  indexedelem . indexed1   (rule 68)

    ',' 	shift, and go to state 98

    $default	reduce using rule 69 (indexed1)

    indexed1	go to state 99



state 38

    stmt  ->  block .   (rule 11)

    $default	reduce using rule 11 (stmt)



state 39

    stmt  ->  funcdef .   (rule 12)

    $default	reduce using rule 12 (stmt)



state 40

    primary  ->  const .   (rule 43)

    $default	reduce using rule 43 (primary)



state 41

    stmt  ->  ifstmt .   (rule 5)

    $default	reduce using rule 5 (stmt)



state 42

    stmt  ->  whilestmt .   (rule 6)

    $default	reduce using rule 6 (stmt)



state 43

    stmt  ->  forstmt .   (rule 7)

    $default	reduce using rule 7 (stmt)



state 44

    stmt  ->  returnstmt .   (rule 8)

    $default	reduce using rule 8 (stmt)



state 45

    stmt  ->  BREAK ';' .   (rule 9)

    $default	reduce using rule 9 (stmt)



state 46

    stmt  ->  CONTINUE ';' .   (rule 10)

    $default	reduce using rule 10 (stmt)



state 47

    indexedelem  ->  '{' . expr ':' expr '}'   (rule 71)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 65
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 48

    expr  ->  expr . op expr   (rule 15)
    term  ->  NOT expr .   (rule 32)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    '*' 	[reduce using rule 32 (term)]
    '+' 	[reduce using rule 32 (term)]
    $default	reduce using rule 32 (term)

    op  	go to state 83
    elist1	go to state 84



state 49

    expr  ->  expr . op expr   (rule 15)
    term  ->  UMINUS expr .   (rule 31)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    '*' 	[reduce using rule 31 (term)]
    '+' 	[reduce using rule 31 (term)]
    $default	reduce using rule 31 (term)

    op  	go to state 83
    elist1	go to state 84



state 50

    call  ->  '(' . funcdef ')' '(' elist ')'   (rule 53)

    FUNCTION	shift, and go to state 10

    funcdef	go to state 100



state 51

    term  ->  PLUSPLUS lvalue .   (rule 33)
    member  ->  lvalue . '.' ID   (rule 48)
    member  ->  lvalue . '[' expr ']'   (rule 49)
    call  ->  lvalue . callsuffix   (rule 52)

    DOUPLEDOT	shift, and go to state 87
    '.' 	shift, and go to state 90

    $default	reduce using rule 33 (term)

    callsuffix	go to state 92
    normcall	go to state 93
    methodcall	go to state 94



state 52

    member  ->  call . '.' ID call '[' expr ']'   (rule 50)
    call  ->  call . '(' elist ')'   (rule 51)

    '(' 	shift, and go to state 95
    '.' 	shift, and go to state 96



state 53

    term  ->  MINUSMINUS lvalue .   (rule 35)
    member  ->  lvalue . '.' ID   (rule 48)
    member  ->  lvalue . '[' expr ']'   (rule 49)
    call  ->  lvalue . callsuffix   (rule 52)

    DOUPLEDOT	shift, and go to state 87
    '.' 	shift, and go to state 90

    $default	reduce using rule 35 (term)

    callsuffix	go to state 92
    normcall	go to state 93
    methodcall	go to state 94



state 54

    lvalue  ->  LOCAL ID .   (rule 45)

    $default	reduce using rule 45 (lvalue)



state 55

    lvalue  ->  SCOPEOP ID .   (rule 46)

    $default	reduce using rule 46 (lvalue)



state 56

    funcdef1  ->  ID .   (rule 76)

    $default	reduce using rule 76 (funcdef1)



state 57

    funcdef  ->  FUNCTION funcdef1 . '(' idlist ')' block   (rule 74)

    '(' 	shift, and go to state 101



state 58

    ifstmt  ->  IF '(' . expr ')' stmt ifstmt1   (rule 86)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 102
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 59

    whilestmt  ->  WHILE '(' . expr ')' stmt   (rule 89)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 103
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 60

    forstmt  ->  FOR '(' . elist ';' expr ';' elist ')' stmt   (rule 90)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 104
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 105
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 61

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)
    returnstmt1  ->  expr .   (rule 93)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    '*' 	[reduce using rule 93 (returnstmt1)]
    '+' 	[reduce using rule 93 (returnstmt1)]
    $default	reduce using rule 93 (returnstmt1)

    op  	go to state 83
    elist1	go to state 84



state 62

    returnstmt  ->  RETURN returnstmt1 .   (rule 91)

    $default	reduce using rule 91 (returnstmt)



state 63

    expr  ->  expr . op expr   (rule 15)
    term  ->  '(' expr . ')'   (rule 30)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    ')' 	shift, and go to state 106
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 64

    primary  ->  '(' funcdef . ')'   (rule 42)
    call  ->  '(' funcdef . ')' '(' elist ')'   (rule 53)

    ')' 	shift, and go to state 107



state 65

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)
    indexedelem  ->  '{' expr . ':' expr '}'   (rule 71)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82
    ':' 	shift, and go to state 108

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 66

    block  ->  stmt1 '}' .   (rule 73)

    $default	reduce using rule 73 (block)



state 67

    stmt1  ->  stmt stmt1 .   (rule 3)
    block  ->  stmt1 . '}'   (rule 73)

    '}' 	shift, and go to state 66

    '}' 	[reduce using rule 3 (stmt1)]
    $default	reduce using rule 3 (stmt1)



state 68

    op  ->  AND .   (rule 28)

    $default	reduce using rule 28 (op)



state 69

    op  ->  OR .   (rule 29)

    $default	reduce using rule 29 (op)



state 70

    op  ->  GREATEREQUAL .   (rule 23)

    $default	reduce using rule 23 (op)



state 71

    op  ->  LESSEQUAL .   (rule 25)

    $default	reduce using rule 25 (op)



state 72

    op  ->  EQUAL .   (rule 26)

    $default	reduce using rule 26 (op)



state 73

    op  ->  NOTEQUAL .   (rule 27)

    $default	reduce using rule 27 (op)



state 74

    op  ->  '*' .   (rule 19)

    $default	reduce using rule 19 (op)



state 75

    op  ->  '/' .   (rule 20)

    $default	reduce using rule 20 (op)



state 76

    op  ->  '%' .   (rule 21)

    $default	reduce using rule 21 (op)



state 77

    op  ->  '+' .   (rule 17)

    $default	reduce using rule 17 (op)



state 78

    op  ->  '-' .   (rule 18)

    $default	reduce using rule 18 (op)



state 79

    stmt  ->  expr ';' .   (rule 4)

    $default	reduce using rule 4 (stmt)



state 80

    op  ->  '>' .   (rule 22)

    $default	reduce using rule 22 (op)



state 81

    op  ->  '<' .   (rule 24)

    $default	reduce using rule 24 (op)



state 82

    elist1  ->  ',' . expr elist1   (rule 61)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 109
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 83

    expr  ->  expr op . expr   (rule 15)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 110
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 84

    elist  ->  expr elist1 .   (rule 59)

    $default	reduce using rule 59 (elist)



state 85

    term  ->  lvalue PLUSPLUS .   (rule 34)

    $default	reduce using rule 34 (term)



state 86

    term  ->  lvalue MINUSMINUS .   (rule 36)

    $default	reduce using rule 36 (term)



state 87

    methodcall  ->  DOUPLEDOT . ID '(' elist ')'   (rule 57)

    ID  	shift, and go to state 111



state 88

    normcall  ->  '(' . elist ')'   (rule 56)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 104
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 112
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 89

    member  ->  lvalue '[' . expr ']'   (rule 49)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 113
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 90

    member  ->  lvalue '.' . ID   (rule 48)

    ID  	shift, and go to state 114



state 91

    assignexpr  ->  lvalue '=' . expr   (rule 38)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 115
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 92

    call  ->  lvalue callsuffix .   (rule 52)

    $default	reduce using rule 52 (call)



state 93

    callsuffix  ->  normcall .   (rule 54)

    $default	reduce using rule 54 (callsuffix)



state 94

    callsuffix  ->  methodcall .   (rule 55)

    $default	reduce using rule 55 (callsuffix)



state 95

    call  ->  call '(' . elist ')'   (rule 51)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 104
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 116
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 96

    member  ->  call '.' . ID call '[' expr ']'   (rule 50)

    ID  	shift, and go to state 117



state 97

    objectdef  ->  objectdef1 ']' .   (rule 63)

    $default	reduce using rule 63 (objectdef)



state 98

    indexed1  ->  ',' . indexedelem indexed1   (rule 70)

    '{' 	shift, and go to state 47

    indexedelem	go to state 118



state 99

    indexed  ->  indexedelem indexed1 .   (rule 68)

    $default	reduce using rule 68 (indexed)



state 100

    call  ->  '(' funcdef . ')' '(' elist ')'   (rule 53)

    ')' 	shift, and go to state 119



state 101

    funcdef  ->  FUNCTION funcdef1 '(' . idlist ')' block   (rule 74)

    ID  	shift, and go to state 120

    $default	reduce using rule 82 (idlist)

    idlist	go to state 121



state 102

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)
    ifstmt  ->  IF '(' expr . ')' stmt ifstmt1   (rule 86)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    ')' 	shift, and go to state 122
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 103

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)
    whilestmt  ->  WHILE '(' expr . ')' stmt   (rule 89)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    ')' 	shift, and go to state 123
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 104

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 105

    objectdef1  ->  elist .   (rule 65)
    forstmt  ->  FOR '(' elist . ';' expr ';' elist ')' stmt   (rule 90)

    ';' 	shift, and go to state 124

    $default	reduce using rule 65 (objectdef1)



state 106

    term  ->  '(' expr ')' .   (rule 30)

    $default	reduce using rule 30 (term)



state 107

    primary  ->  '(' funcdef ')' .   (rule 42)
    call  ->  '(' funcdef ')' . '(' elist ')'   (rule 53)


    $default	reduce using rule 42 (primary)



state 108

    indexedelem  ->  '{' expr ':' . expr '}'   (rule 71)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 126
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 109

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)
    elist1  ->  ',' expr . elist1   (rule 61)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 127



state 110

    expr  ->  expr . op expr   (rule 15)
    expr  ->  expr op expr .   (rule 15)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    AND 	[reduce using rule 15 (expr)]
    OR  	[reduce using rule 15 (expr)]
    GREATEREQUAL	[reduce using rule 15 (expr)]
    LESSEQUAL	[reduce using rule 15 (expr)]
    EQUAL	[reduce using rule 15 (expr)]
    NOTEQUAL	[reduce using rule 15 (expr)]
    '*' 	[reduce using rule 15 (expr)]
    '/' 	[reduce using rule 15 (expr)]
    '%' 	[reduce using rule 15 (expr)]
    '+' 	[reduce using rule 15 (expr)]
    '>' 	[reduce using rule 15 (expr)]
    '<' 	[reduce using rule 15 (expr)]
    ',' 	[reduce using rule 15 (expr)]
    $default	reduce using rule 15 (expr)

    op  	go to state 83
    elist1	go to state 84



state 111

    methodcall  ->  DOUPLEDOT ID . '(' elist ')'   (rule 57)

    '(' 	shift, and go to state 128



state 112

    normcall  ->  '(' elist . ')'   (rule 56)
    objectdef1  ->  elist .   (rule 65)

    ')' 	shift, and go to state 129

    $default	reduce using rule 65 (objectdef1)



state 113

    expr  ->  expr . op expr   (rule 15)
    member  ->  lvalue '[' expr . ']'   (rule 49)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    ']' 	shift, and go to state 130
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    ']' 	[reduce using rule 60 (elist1)]
    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 114

    member  ->  lvalue '.' ID .   (rule 48)

    $default	reduce using rule 48 (member)



state 115

    expr  ->  expr . op expr   (rule 15)
    assignexpr  ->  lvalue '=' expr .   (rule 38)
    elist  ->  expr . elist1   (rule 59)

    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    '>' 	[reduce using rule 38 (assignexpr)]
    '<' 	[reduce using rule 38 (assignexpr)]
    ',' 	[reduce using rule 38 (assignexpr)]
    $default	reduce using rule 38 (assignexpr)

    op  	go to state 83
    elist1	go to state 84



state 116

    call  ->  call '(' elist . ')'   (rule 51)
    objectdef1  ->  elist .   (rule 65)

    ')' 	shift, and go to state 131

    $default	reduce using rule 65 (objectdef1)



state 117

    member  ->  call '.' ID . call '[' expr ']'   (rule 50)

    ID  	shift, and go to state 1
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    '(' 	shift, and go to state 50

    lvalue	go to state 132
    member	go to state 31
    call	go to state 133



state 118

    indexed1  ->  ',' indexedelem . indexed1   (rule 70)

    ',' 	shift, and go to state 98

    $default	reduce using rule 69 (indexed1)

    indexed1	go to state 134



state 119

    call  ->  '(' funcdef ')' . '(' elist ')'   (rule 53)

    '(' 	shift, and go to state 125



state 120

    idlist  ->  ID . idlist1   (rule 83)

    ',' 	shift, and go to state 135

    $default	reduce using rule 84 (idlist1)

    idlist1	go to state 136



state 121

    funcdef  ->  FUNCTION funcdef1 '(' idlist . ')' block   (rule 74)

    ')' 	shift, and go to state 137



state 122

    ifstmt  ->  IF '(' expr ')' . stmt ifstmt1   (rule 86)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    $default	reduce using rule 2 (stmt1)

    stmt1	go to state 138
    stmt	go to state 139
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 123

    whilestmt  ->  WHILE '(' expr ')' . stmt   (rule 89)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    $default	reduce using rule 2 (stmt1)

    stmt1	go to state 138
    stmt	go to state 140
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 124

    forstmt  ->  FOR '(' elist ';' . expr ';' elist ')' stmt   (rule 90)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 141
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 125

    call  ->  '(' funcdef ')' '(' . elist ')'   (rule 53)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 104
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 142
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 126

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)
    indexedelem  ->  '{' expr ':' expr . '}'   (rule 71)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82
    '}' 	shift, and go to state 143

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 127

    elist  ->  expr elist1 .   (rule 59)
    elist1  ->  ',' expr elist1 .   (rule 61)

    $default	reduce using rule 61 (elist1)



state 128

    methodcall  ->  DOUPLEDOT ID '(' . elist ')'   (rule 57)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 104
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 144
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 129

    normcall  ->  '(' elist ')' .   (rule 56)

    $default	reduce using rule 56 (normcall)



state 130

    member  ->  lvalue '[' expr ']' .   (rule 49)

    $default	reduce using rule 49 (member)



state 131

    call  ->  call '(' elist ')' .   (rule 51)

    $default	reduce using rule 51 (call)



state 132

    member  ->  lvalue . '.' ID   (rule 48)
    member  ->  lvalue . '[' expr ']'   (rule 49)
    call  ->  lvalue . callsuffix   (rule 52)

    DOUPLEDOT	shift, and go to state 87
    '(' 	shift, and go to state 88
    '[' 	shift, and go to state 89
    '.' 	shift, and go to state 90

    callsuffix	go to state 92
    normcall	go to state 93
    methodcall	go to state 94



state 133

    member  ->  call . '.' ID call '[' expr ']'   (rule 50)
    member  ->  call '.' ID call . '[' expr ']'   (rule 50)
    call  ->  call . '(' elist ')'   (rule 51)

    '(' 	shift, and go to state 95
    '[' 	shift, and go to state 145
    '.' 	shift, and go to state 96



state 134

    indexed1  ->  ',' indexedelem indexed1 .   (rule 70)

    $default	reduce using rule 70 (indexed1)



state 135

    idlist1  ->  ',' . ID idlist1   (rule 85)

    ID  	shift, and go to state 146



state 136

    idlist  ->  ID idlist1 .   (rule 83)

    $default	reduce using rule 83 (idlist)



state 137

    funcdef  ->  FUNCTION funcdef1 '(' idlist ')' . block   (rule 74)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    $default	reduce using rule 2 (stmt1)

    stmt1	go to state 138
    stmt	go to state 25
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 147
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 138

    block  ->  stmt1 . '}'   (rule 73)

    '}' 	shift, and go to state 66



state 139

    stmt1  ->  stmt . stmt1   (rule 3)
    ifstmt  ->  IF '(' expr ')' stmt . ifstmt1   (rule 86)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    ELSE	shift, and go to state 148
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    $   	reduce using rule 87 (ifstmt1)
    ID  	[reduce using rule 87 (ifstmt1)]
    BREAK	[reduce using rule 87 (ifstmt1)]
    CONTINUE	[reduce using rule 87 (ifstmt1)]
    NOT 	[reduce using rule 87 (ifstmt1)]
    UMINUS	[reduce using rule 87 (ifstmt1)]
    PLUSPLUS	[reduce using rule 87 (ifstmt1)]
    MINUSMINUS	[reduce using rule 87 (ifstmt1)]
    LOCAL	[reduce using rule 87 (ifstmt1)]
    SCOPEOP	[reduce using rule 87 (ifstmt1)]
    FUNCTION	[reduce using rule 87 (ifstmt1)]
    NUMBER	[reduce using rule 87 (ifstmt1)]
    STRING	[reduce using rule 87 (ifstmt1)]
    NIL 	[reduce using rule 87 (ifstmt1)]
    TRUE	[reduce using rule 87 (ifstmt1)]
    FALSE	[reduce using rule 87 (ifstmt1)]
    IF  	[reduce using rule 87 (ifstmt1)]
    ELSE	[reduce using rule 87 (ifstmt1)]
    WHILE	[reduce using rule 87 (ifstmt1)]
    FOR 	[reduce using rule 87 (ifstmt1)]
    RETURN	[reduce using rule 87 (ifstmt1)]
    '(' 	[reduce using rule 87 (ifstmt1)]
    ']' 	reduce using rule 87 (ifstmt1)
    '.' 	reduce using rule 87 (ifstmt1)
    '*' 	reduce using rule 87 (ifstmt1)
    '+' 	reduce using rule 87 (ifstmt1)
    '{' 	[reduce using rule 87 (ifstmt1)]
    ':' 	reduce using rule 87 (ifstmt1)
    '}' 	reduce using rule 87 (ifstmt1)
    $default	reduce using rule 2 (stmt1)

    stmt1	go to state 67
    stmt	go to state 25
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    ifstmt1	go to state 149
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 140

    stmt1  ->  stmt . stmt1   (rule 3)
    whilestmt  ->  WHILE '(' expr ')' stmt .   (rule 89)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    ID  	[reduce using rule 89 (whilestmt)]
    BREAK	[reduce using rule 89 (whilestmt)]
    CONTINUE	[reduce using rule 89 (whilestmt)]
    LOCAL	[reduce using rule 89 (whilestmt)]
    SCOPEOP	[reduce using rule 89 (whilestmt)]
    FUNCTION	[reduce using rule 89 (whilestmt)]
    NUMBER	[reduce using rule 89 (whilestmt)]
    STRING	[reduce using rule 89 (whilestmt)]
    NIL 	[reduce using rule 89 (whilestmt)]
    TRUE	[reduce using rule 89 (whilestmt)]
    FALSE	[reduce using rule 89 (whilestmt)]
    IF  	[reduce using rule 89 (whilestmt)]
    WHILE	[reduce using rule 89 (whilestmt)]
    FOR 	[reduce using rule 89 (whilestmt)]
    RETURN	[reduce using rule 89 (whilestmt)]
    $default	reduce using rule 89 (whilestmt)

    stmt1	go to state 67
    stmt	go to state 25
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 141

    expr  ->  expr . op expr   (rule 15)
    elist  ->  expr . elist1   (rule 59)
    forstmt  ->  FOR '(' elist ';' expr . ';' elist ')' stmt   (rule 90)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    ';' 	shift, and go to state 150
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 142

    call  ->  '(' funcdef ')' '(' elist . ')'   (rule 53)
    objectdef1  ->  elist .   (rule 65)

    ')' 	shift, and go to state 151

    $default	reduce using rule 65 (objectdef1)



state 143

    indexedelem  ->  '{' expr ':' expr '}' .   (rule 71)

    $default	reduce using rule 71 (indexedelem)



state 144

    methodcall  ->  DOUPLEDOT ID '(' elist . ')'   (rule 57)
    objectdef1  ->  elist .   (rule 65)

    ')' 	shift, and go to state 152

    $default	reduce using rule 65 (objectdef1)



state 145

    member  ->  call '.' ID call '[' . expr ']'   (rule 50)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 153
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 146

    idlist1  ->  ',' ID . idlist1   (rule 85)

    ',' 	shift, and go to state 135

    $default	reduce using rule 84 (idlist1)

    idlist1	go to state 154



state 147

    stmt  ->  block .   (rule 11)
    funcdef  ->  FUNCTION funcdef1 '(' idlist ')' block .   (rule 74)

    $   	reduce using rule 74 (funcdef)
    ID  	reduce using rule 11 (stmt)
    ID  	[reduce using rule 74 (funcdef)]
    BREAK	reduce using rule 11 (stmt)
    BREAK	[reduce using rule 74 (funcdef)]
    CONTINUE	reduce using rule 11 (stmt)
    CONTINUE	[reduce using rule 74 (funcdef)]
    NOT 	reduce using rule 11 (stmt)
    NOT 	[reduce using rule 74 (funcdef)]
    UMINUS	reduce using rule 11 (stmt)
    UMINUS	[reduce using rule 74 (funcdef)]
    PLUSPLUS	reduce using rule 11 (stmt)
    PLUSPLUS	[reduce using rule 74 (funcdef)]
    MINUSMINUS	reduce using rule 11 (stmt)
    MINUSMINUS	[reduce using rule 74 (funcdef)]
    LOCAL	reduce using rule 11 (stmt)
    LOCAL	[reduce using rule 74 (funcdef)]
    SCOPEOP	reduce using rule 11 (stmt)
    SCOPEOP	[reduce using rule 74 (funcdef)]
    FUNCTION	reduce using rule 11 (stmt)
    FUNCTION	[reduce using rule 74 (funcdef)]
    NUMBER	reduce using rule 11 (stmt)
    NUMBER	[reduce using rule 74 (funcdef)]
    STRING	reduce using rule 11 (stmt)
    STRING	[reduce using rule 74 (funcdef)]
    NIL 	reduce using rule 11 (stmt)
    NIL 	[reduce using rule 74 (funcdef)]
    TRUE	reduce using rule 11 (stmt)
    TRUE	[reduce using rule 74 (funcdef)]
    FALSE	reduce using rule 11 (stmt)
    FALSE	[reduce using rule 74 (funcdef)]
    IF  	reduce using rule 11 (stmt)
    IF  	[reduce using rule 74 (funcdef)]
    ELSE	reduce using rule 74 (funcdef)
    WHILE	reduce using rule 11 (stmt)
    WHILE	[reduce using rule 74 (funcdef)]
    FOR 	reduce using rule 11 (stmt)
    FOR 	[reduce using rule 74 (funcdef)]
    RETURN	reduce using rule 11 (stmt)
    RETURN	[reduce using rule 74 (funcdef)]
    '(' 	reduce using rule 74 (funcdef)
    ']' 	reduce using rule 11 (stmt)
    ']' 	[reduce using rule 74 (funcdef)]
    '.' 	reduce using rule 11 (stmt)
    '.' 	[reduce using rule 74 (funcdef)]
    '*' 	reduce using rule 11 (stmt)
    '*' 	[reduce using rule 74 (funcdef)]
    '+' 	reduce using rule 11 (stmt)
    '+' 	[reduce using rule 74 (funcdef)]
    '{' 	reduce using rule 11 (stmt)
    '{' 	[reduce using rule 74 (funcdef)]
    ':' 	reduce using rule 11 (stmt)
    ':' 	[reduce using rule 74 (funcdef)]
    '}' 	reduce using rule 11 (stmt)
    '}' 	[reduce using rule 74 (funcdef)]
    $default	reduce using rule 11 (stmt)



state 148

    ifstmt1  ->  ELSE . stmt   (rule 88)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    $default	reduce using rule 2 (stmt1)

    stmt1	go to state 138
    stmt	go to state 155
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 149

    ifstmt  ->  IF '(' expr ')' stmt ifstmt1 .   (rule 86)

    $default	reduce using rule 86 (ifstmt)



state 150

    forstmt  ->  FOR '(' elist ';' expr ';' . elist ')' stmt   (rule 90)

    ID  	shift, and go to state 1
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    '{' 	shift, and go to state 47

    $default	reduce using rule 58 (elist)

    expr	go to state 104
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 156
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    const	go to state 40



state 151

    call  ->  '(' funcdef ')' '(' elist ')' .   (rule 53)

    $default	reduce using rule 53 (call)



state 152

    methodcall  ->  DOUPLEDOT ID '(' elist ')' .   (rule 57)

    $default	reduce using rule 57 (methodcall)



state 153

    expr  ->  expr . op expr   (rule 15)
    member  ->  call '.' ID call '[' expr . ']'   (rule 50)
    elist  ->  expr . elist1   (rule 59)

    AND 	shift, and go to state 68
    OR  	shift, and go to state 69
    GREATEREQUAL	shift, and go to state 70
    LESSEQUAL	shift, and go to state 71
    EQUAL	shift, and go to state 72
    NOTEQUAL	shift, and go to state 73
    ']' 	shift, and go to state 157
    '*' 	shift, and go to state 74
    '/' 	shift, and go to state 75
    '%' 	shift, and go to state 76
    '+' 	shift, and go to state 77
    '-' 	shift, and go to state 78
    '>' 	shift, and go to state 80
    '<' 	shift, and go to state 81
    ',' 	shift, and go to state 82

    ']' 	[reduce using rule 60 (elist1)]
    $default	reduce using rule 60 (elist1)

    op  	go to state 83
    elist1	go to state 84



state 154

    idlist1  ->  ',' ID idlist1 .   (rule 85)

    $default	reduce using rule 85 (idlist1)



state 155

    stmt1  ->  stmt . stmt1   (rule 3)
    ifstmt1  ->  ELSE stmt .   (rule 88)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    ID  	[reduce using rule 88 (ifstmt1)]
    BREAK	[reduce using rule 88 (ifstmt1)]
    CONTINUE	[reduce using rule 88 (ifstmt1)]
    NOT 	[reduce using rule 88 (ifstmt1)]
    UMINUS	[reduce using rule 88 (ifstmt1)]
    PLUSPLUS	[reduce using rule 88 (ifstmt1)]
    MINUSMINUS	[reduce using rule 88 (ifstmt1)]
    LOCAL	[reduce using rule 88 (ifstmt1)]
    SCOPEOP	[reduce using rule 88 (ifstmt1)]
    FUNCTION	[reduce using rule 88 (ifstmt1)]
    NUMBER	[reduce using rule 88 (ifstmt1)]
    STRING	[reduce using rule 88 (ifstmt1)]
    NIL 	[reduce using rule 88 (ifstmt1)]
    TRUE	[reduce using rule 88 (ifstmt1)]
    FALSE	[reduce using rule 88 (ifstmt1)]
    IF  	[reduce using rule 88 (ifstmt1)]
    WHILE	[reduce using rule 88 (ifstmt1)]
    FOR 	[reduce using rule 88 (ifstmt1)]
    RETURN	[reduce using rule 88 (ifstmt1)]
    '(' 	[reduce using rule 88 (ifstmt1)]
    '{' 	[reduce using rule 88 (ifstmt1)]
    $default	reduce using rule 88 (ifstmt1)

    stmt1	go to state 67
    stmt	go to state 25
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 156

    objectdef1  ->  elist .   (rule 65)
    forstmt  ->  FOR '(' elist ';' expr ';' elist . ')' stmt   (rule 90)

    ')' 	shift, and go to state 158

    $default	reduce using rule 65 (objectdef1)



state 157

    member  ->  call '.' ID call '[' expr ']' .   (rule 50)

    $default	reduce using rule 50 (member)



state 158

    forstmt  ->  FOR '(' elist ';' expr ';' elist ')' . stmt   (rule 90)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '(' 	shift, and go to state 20
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    $default	reduce using rule 2 (stmt1)

    stmt1	go to state 138
    stmt	go to state 159
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 159

    stmt1  ->  stmt . stmt1   (rule 3)
    forstmt  ->  FOR '(' elist ';' expr ';' elist ')' stmt .   (rule 90)

    ID  	shift, and go to state 1
    BREAK	shift, and go to state 2
    CONTINUE	shift, and go to state 3
    NOT 	shift, and go to state 4
    UMINUS	shift, and go to state 5
    PLUSPLUS	shift, and go to state 6
    MINUSMINUS	shift, and go to state 7
    LOCAL	shift, and go to state 8
    SCOPEOP	shift, and go to state 9
    FUNCTION	shift, and go to state 10
    NUMBER	shift, and go to state 11
    STRING	shift, and go to state 12
    NIL 	shift, and go to state 13
    TRUE	shift, and go to state 14
    FALSE	shift, and go to state 15
    IF  	shift, and go to state 16
    WHILE	shift, and go to state 17
    FOR 	shift, and go to state 18
    RETURN	shift, and go to state 19
    '[' 	shift, and go to state 21
    ';' 	shift, and go to state 22
    '{' 	shift, and go to state 23

    ID  	[reduce using rule 90 (forstmt)]
    BREAK	[reduce using rule 90 (forstmt)]
    CONTINUE	[reduce using rule 90 (forstmt)]
    LOCAL	[reduce using rule 90 (forstmt)]
    SCOPEOP	[reduce using rule 90 (forstmt)]
    FUNCTION	[reduce using rule 90 (forstmt)]
    NUMBER	[reduce using rule 90 (forstmt)]
    STRING	[reduce using rule 90 (forstmt)]
    NIL 	[reduce using rule 90 (forstmt)]
    TRUE	[reduce using rule 90 (forstmt)]
    FALSE	[reduce using rule 90 (forstmt)]
    IF  	[reduce using rule 90 (forstmt)]
    WHILE	[reduce using rule 90 (forstmt)]
    FOR 	[reduce using rule 90 (forstmt)]
    RETURN	[reduce using rule 90 (forstmt)]
    $default	reduce using rule 90 (forstmt)

    stmt1	go to state 67
    stmt	go to state 25
    expr	go to state 26
    term	go to state 27
    assignexpr	go to state 28
    primary	go to state 29
    lvalue	go to state 30
    member	go to state 31
    call	go to state 32
    elist	go to state 33
    objectdef	go to state 34
    objectdef1	go to state 35
    indexed	go to state 36
    indexedelem	go to state 37
    block	go to state 38
    funcdef	go to state 39
    const	go to state 40
    ifstmt	go to state 41
    whilestmt	go to state 42
    forstmt	go to state 43
    returnstmt	go to state 44



state 160

    $   	go to state 161



state 161

    $   	go to state 162



state 162

    $default	accept
