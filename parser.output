Rules useless in parser due to conflicts

   64 objectdef1: %empty

   67 indexed: %empty


State 0 conflicts: 1 reduce/reduce
State 4 conflicts: 1 reduce/reduce
State 5 conflicts: 1 reduce/reduce
State 19 conflicts: 15 shift/reduce, 1 reduce/reduce
State 20 conflicts: 1 reduce/reduce
State 23 conflicts: 15 shift/reduce, 1 reduce/reduce
State 26 conflicts: 1 reduce/reduce
State 31 conflicts: 4 shift/reduce
State 33 conflicts: 1 shift/reduce
State 48 conflicts: 1 reduce/reduce
State 49 conflicts: 1 shift/reduce, 1 reduce/reduce
State 50 conflicts: 1 shift/reduce, 1 reduce/reduce
State 59 conflicts: 1 reduce/reduce
State 60 conflicts: 1 reduce/reduce
State 61 conflicts: 1 reduce/reduce
State 62 conflicts: 1 reduce/reduce
State 69 conflicts: 1 shift/reduce
State 84 conflicts: 1 reduce/reduce
State 85 conflicts: 1 reduce/reduce
State 90 conflicts: 1 reduce/reduce
State 91 conflicts: 1 reduce/reduce
State 93 conflicts: 1 reduce/reduce
State 97 conflicts: 1 reduce/reduce
State 110 conflicts: 1 reduce/reduce
State 112 conflicts: 14 shift/reduce, 1 reduce/reduce
State 115 conflicts: 1 shift/reduce
State 117 conflicts: 1 shift/reduce, 1 reduce/reduce
State 124 conflicts: 1 reduce/reduce
State 125 conflicts: 1 reduce/reduce
State 126 conflicts: 1 reduce/reduce
State 127 conflicts: 1 reduce/reduce
State 129 conflicts: 1 reduce/reduce
State 130 conflicts: 1 reduce/reduce
State 139 conflicts: 1 reduce/reduce
State 141 conflicts: 24 shift/reduce, 2 reduce/reduce
State 142 conflicts: 17 shift/reduce, 2 reduce/reduce
State 147 conflicts: 1 reduce/reduce
State 149 conflicts: 25 reduce/reduce
State 150 conflicts: 1 reduce/reduce
State 152 conflicts: 1 reduce/reduce
State 155 conflicts: 1 shift/reduce
State 157 conflicts: 23 shift/reduce, 2 reduce/reduce
State 160 conflicts: 1 reduce/reduce
State 161 conflicts: 17 shift/reduce, 2 reduce/reduce


Grammar

    0 $accept: program $end

    1 program: stmt1

    2 stmt1: %empty
    3      | stmt stmt1

    4 stmt: expr ';'
    5     | ifstmt
    6     | whilestmt
    7     | forstmt
    8     | returnstmt
    9     | BREAK ';'
   10     | CONTINUE ';'
   11     | block
   12     | funcdef
   13     | ';'

   14 expr: assignexpr
   15     | expr op expr
   16     | term

   17 op: '+'
   18   | '-'
   19   | '*'
   20   | '/'
   21   | '%'
   22   | '>'
   23   | GREATEREQUAL
   24   | '<'
   25   | LESSEQUAL
   26   | EQUAL
   27   | NOTEQUAL
   28   | AND
   29   | OR

   30 term: '(' expr ')'
   31     | UMINUS expr
   32     | NOT expr
   33     | PLUSPLUS lvalue
   34     | lvalue PLUSPLUS
   35     | MINUSMINUS lvalue
   36     | lvalue MINUSMINUS
   37     | primary

   38 assignexpr: lvalue '=' expr

   39 primary: lvalue
   40        | call
   41        | objectdef
   42        | '(' funcdef ')'
   43        | const

   44 lvalue: ID
   45       | LOCAL ID
   46       | SCOPEOP ID
   47       | member

   48 member: lvalue '.' ID
   49       | lvalue '[' expr ']'
   50       | call '.' ID call '[' expr ']'

   51 call: call '(' elist ')'
   52     | lvalue callsuffix
   53     | '(' funcdef ')' '(' elist ')'

   54 callsuffix: normcall
   55           | methodcall

   56 normcall: '(' elist ')'

   57 methodcall: DOUPLEDOT ID '(' elist ')'

   58 elist: %empty
   59      | expr elist1

   60 elist1: %empty
   61       | ',' expr elist1

   62 objectdef: '['
   63          | objectdef1 ']'

   64 objectdef1: %empty
   65           | elist
   66           | indexed

   67 indexed: %empty
   68        | indexedelem indexed1

   69 indexed1: %empty
   70         | ',' indexedelem indexed1

   71 indexedelem: '{' expr ':' expr '}'

   72 block: '{'
   73      | stmt1 '}'

   74 funcdef: FUNCTION funcdef1 '(' idlist ')' block

   75 funcdef1: %empty
   76         | ID

   77 const: NUMBER
   78      | STRING
   79      | NIL
   80      | TRUE
   81      | FALSE

   82 idlist: %empty
   83       | ID idlist1

   84 idlist1: %empty
   85        | ',' ID idlist1

   86 ifstmt: IF '(' expr ')' stmt ifstmt1

   87 ifstmt1: %empty
   88        | ELSE stmt

   89 whilestmt: WHILE '(' expr ')' stmt

   90 forstmt: FOR '(' elist ';' expr ';' elist ')' stmt

   91 returnstmt: RETURN returnstmt1

   92 returnstmt1: %empty
   93            | expr


Terminals, with rules where they appear

$end (0) 0
'%' (37) 21
'(' (40) 30 42 51 53 56 57 74 86 89 90
')' (41) 30 42 51 53 56 57 74 86 89 90
'*' (42) 19
'+' (43) 17
',' (44) 61 70 85
'-' (45) 18
'.' (46) 48 50
'/' (47) 20
':' (58) 71
';' (59) 4 9 10 13 90
'<' (60) 24
'=' (61) 38
'>' (62) 22
'[' (91) 49 50 62
']' (93) 49 50 63
'{' (123) 71 72
'}' (125) 71 73
error (256)
ID (258) 44 45 46 48 50 57 76 83 85
BREAK (259) 9
CONTINUE (260) 10
AND (261) 28
OR (262) 29
NOT (263) 32
GREATEREQUAL (264) 23
LESSEQUAL (265) 25
EQUAL (266) 26
NOTEQUAL (267) 27
UMINUS (268) 31
PLUSPLUS (269) 33 34
MINUSMINUS (270) 35 36
LOCAL (271) 45
SCOPEOP (272) 46
DOUPLEDOT (273) 57
FUNCTION (274) 74
NUMBER (275) 77
STRING (276) 78
NIL (277) 79
TRUE (278) 80
FALSE (279) 81
IF (280) 86
ELSE (281) 88
WHILE (282) 89
FOR (283) 90
RETURN (284) 91


Nonterminals, with rules where they appear

$accept (48)
    on left: 0
program (49)
    on left: 1, on right: 0
stmt1 (50)
    on left: 2 3, on right: 1 3 73
stmt (51)
    on left: 4 5 6 7 8 9 10 11 12 13, on right: 3 86 88 89 90
expr (52)
    on left: 14 15 16, on right: 4 15 30 31 32 38 49 50 59 61 71 86
    89 90 93
op (53)
    on left: 17 18 19 20 21 22 23 24 25 26 27 28 29, on right: 15
term (54)
    on left: 30 31 32 33 34 35 36 37, on right: 16
assignexpr (55)
    on left: 38, on right: 14
primary (56)
    on left: 39 40 41 42 43, on right: 37
lvalue (57)
    on left: 44 45 46 47, on right: 33 34 35 36 38 39 48 49 52
member (58)
    on left: 48 49 50, on right: 47
call (59)
    on left: 51 52 53, on right: 40 50 51
callsuffix (60)
    on left: 54 55, on right: 52
normcall (61)
    on left: 56, on right: 54
methodcall (62)
    on left: 57, on right: 55
elist (63)
    on left: 58 59, on right: 51 53 56 57 65 90
elist1 (64)
    on left: 60 61, on right: 59 61
objectdef (65)
    on left: 62 63, on right: 41
objectdef1 (66)
    on left: 64 65 66, on right: 63
indexed (67)
    on left: 67 68, on right: 66
indexed1 (68)
    on left: 69 70, on right: 68 70
indexedelem (69)
    on left: 71, on right: 68 70
block (70)
    on left: 72 73, on right: 11 74
funcdef (71)
    on left: 74, on right: 12 42 53
funcdef1 (72)
    on left: 75 76, on right: 74
const (73)
    on left: 77 78 79 80 81, on right: 43
idlist (74)
    on left: 82 83, on right: 74
idlist1 (75)
    on left: 84 85, on right: 83 85
ifstmt (76)
    on left: 86, on right: 5
ifstmt1 (77)
    on left: 87 88, on right: 86
whilestmt (78)
    on left: 89, on right: 6
forstmt (79)
    on left: 90, on right: 7
returnstmt (80)
    on left: 91, on right: 8
returnstmt1 (81)
    on left: 92 93, on right: 91


State 0

    0 $accept: . program $end

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 2 (stmt1)

    program      go to state 24
    stmt1        go to state 25
    stmt         go to state 26
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 1

   44 lvalue: ID .

    $default  reduce using rule 44 (lvalue)


State 2

    9 stmt: BREAK . ';'

    ';'  shift, and go to state 46


State 3

   10 stmt: CONTINUE . ';'

    ';'  shift, and go to state 47


State 4

   32 term: NOT . expr

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 49
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 5

   31 term: UMINUS . expr

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 50
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 6

   33 term: PLUSPLUS . lvalue

    ID       shift, and go to state 1
    LOCAL    shift, and go to state 8
    SCOPEOP  shift, and go to state 9
    '('      shift, and go to state 51

    lvalue  go to state 52
    member  go to state 32
    call    go to state 53


State 7

   35 term: MINUSMINUS . lvalue

    ID       shift, and go to state 1
    LOCAL    shift, and go to state 8
    SCOPEOP  shift, and go to state 9
    '('      shift, and go to state 51

    lvalue  go to state 54
    member  go to state 32
    call    go to state 53


State 8

   45 lvalue: LOCAL . ID

    ID  shift, and go to state 55


State 9

   46 lvalue: SCOPEOP . ID

    ID  shift, and go to state 56


State 10

   74 funcdef: FUNCTION . funcdef1 '(' idlist ')' block

    ID  shift, and go to state 57

    $default  reduce using rule 75 (funcdef1)

    funcdef1  go to state 58


State 11

   77 const: NUMBER .

    $default  reduce using rule 77 (const)


State 12

   78 const: STRING .

    $default  reduce using rule 78 (const)


State 13

   79 const: NIL .

    $default  reduce using rule 79 (const)


State 14

   80 const: TRUE .

    $default  reduce using rule 80 (const)


State 15

   81 const: FALSE .

    $default  reduce using rule 81 (const)


State 16

   86 ifstmt: IF . '(' expr ')' stmt ifstmt1

    '('  shift, and go to state 59


State 17

   89 whilestmt: WHILE . '(' expr ')' stmt

    '('  shift, and go to state 60


State 18

   90 forstmt: FOR . '(' elist ';' expr ';' elist ')' stmt

    '('  shift, and go to state 61


State 19

   91 returnstmt: RETURN . returnstmt1

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ID          [reduce using rule 92 (returnstmt1)]
    NOT         [reduce using rule 92 (returnstmt1)]
    UMINUS      [reduce using rule 92 (returnstmt1)]
    PLUSPLUS    [reduce using rule 92 (returnstmt1)]
    MINUSMINUS  [reduce using rule 92 (returnstmt1)]
    LOCAL       [reduce using rule 92 (returnstmt1)]
    SCOPEOP     [reduce using rule 92 (returnstmt1)]
    NUMBER      [reduce using rule 92 (returnstmt1)]
    STRING      [reduce using rule 92 (returnstmt1)]
    NIL         [reduce using rule 92 (returnstmt1)]
    TRUE        [reduce using rule 92 (returnstmt1)]
    FALSE       [reduce using rule 92 (returnstmt1)]
    '('         [reduce using rule 92 (returnstmt1)]
    '['         [reduce using rule 92 (returnstmt1)]
    ']'         reduce using rule 58 (elist)
    ']'         [reduce using rule 64 (objectdef1)]
    ']'         [reduce using rule 67 (indexed)]
    ']'         [reduce using rule 92 (returnstmt1)]
    '{'         [reduce using rule 92 (returnstmt1)]
    $default    reduce using rule 92 (returnstmt1)

    expr         go to state 62
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41
    returnstmt1  go to state 63


State 20

   30 term: '(' . expr ')'
   42 primary: '(' . funcdef ')'
   53 call: '(' . funcdef ')' '(' elist ')'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 64
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    funcdef      go to state 65
    const        go to state 41


State 21

   62 objectdef: '[' .

    $default  reduce using rule 62 (objectdef)


State 22

   13 stmt: ';' .

    $default  reduce using rule 13 (stmt)


State 23

   71 indexedelem: '{' . expr ':' expr '}'
   72 block: '{' .

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ID          [reduce using rule 72 (block)]
    NOT         [reduce using rule 72 (block)]
    UMINUS      [reduce using rule 72 (block)]
    PLUSPLUS    [reduce using rule 72 (block)]
    MINUSMINUS  [reduce using rule 72 (block)]
    LOCAL       [reduce using rule 72 (block)]
    SCOPEOP     [reduce using rule 72 (block)]
    NUMBER      [reduce using rule 72 (block)]
    STRING      [reduce using rule 72 (block)]
    NIL         [reduce using rule 72 (block)]
    TRUE        [reduce using rule 72 (block)]
    FALSE       [reduce using rule 72 (block)]
    '('         [reduce using rule 72 (block)]
    '['         [reduce using rule 72 (block)]
    ']'         reduce using rule 58 (elist)
    ']'         [reduce using rule 64 (objectdef1)]
    ']'         [reduce using rule 67 (indexed)]
    ']'         [reduce using rule 72 (block)]
    '{'         [reduce using rule 72 (block)]
    $default    reduce using rule 72 (block)

    expr         go to state 66
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 24

    0 $accept: program . $end

    $end  shift, and go to state 67


State 25

    1 program: stmt1 .
   73 block: stmt1 . '}'

    '}'  shift, and go to state 68

    $default  reduce using rule 1 (program)


State 26

    3 stmt1: stmt . stmt1

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 2 (stmt1)

    stmt1        go to state 69
    stmt         go to state 26
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 27

    4 stmt: expr . ';'
   15 expr: expr . op expr
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ';'           shift, and go to state 83
    ','           shift, and go to state 84

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 28

   16 expr: term .

    $default  reduce using rule 16 (expr)


State 29

   14 expr: assignexpr .

    $default  reduce using rule 14 (expr)


State 30

   37 term: primary .

    $default  reduce using rule 37 (term)


State 31

   34 term: lvalue . PLUSPLUS
   36     | lvalue . MINUSMINUS
   38 assignexpr: lvalue . '=' expr
   39 primary: lvalue .
   48 member: lvalue . '.' ID
   49       | lvalue . '[' expr ']'
   52 call: lvalue . callsuffix

    PLUSPLUS    shift, and go to state 87
    MINUSMINUS  shift, and go to state 88
    DOUPLEDOT   shift, and go to state 89
    '('         shift, and go to state 90
    '['         shift, and go to state 91
    '.'         shift, and go to state 92
    '='         shift, and go to state 93

    PLUSPLUS    [reduce using rule 39 (primary)]
    MINUSMINUS  [reduce using rule 39 (primary)]
    '('         [reduce using rule 39 (primary)]
    '['         [reduce using rule 39 (primary)]
    $default    reduce using rule 39 (primary)

    callsuffix  go to state 94
    normcall    go to state 95
    methodcall  go to state 96


State 32

   47 lvalue: member .

    $default  reduce using rule 47 (lvalue)


State 33

   40 primary: call .
   50 member: call . '.' ID call '[' expr ']'
   51 call: call . '(' elist ')'

    '('  shift, and go to state 97
    '.'  shift, and go to state 98

    '('       [reduce using rule 40 (primary)]
    $default  reduce using rule 40 (primary)


State 34

   65 objectdef1: elist .

    $default  reduce using rule 65 (objectdef1)


State 35

   41 primary: objectdef .

    $default  reduce using rule 41 (primary)


State 36

   63 objectdef: objectdef1 . ']'

    ']'  shift, and go to state 99


State 37

   66 objectdef1: indexed .

    $default  reduce using rule 66 (objectdef1)


State 38

   68 indexed: indexedelem . indexed1

    ','  shift, and go to state 100

    $default  reduce using rule 69 (indexed1)

    indexed1  go to state 101


State 39

   11 stmt: block .

    $default  reduce using rule 11 (stmt)


State 40

   12 stmt: funcdef .

    $default  reduce using rule 12 (stmt)


State 41

   43 primary: const .

    $default  reduce using rule 43 (primary)


State 42

    5 stmt: ifstmt .

    $default  reduce using rule 5 (stmt)


State 43

    6 stmt: whilestmt .

    $default  reduce using rule 6 (stmt)


State 44

    7 stmt: forstmt .

    $default  reduce using rule 7 (stmt)


State 45

    8 stmt: returnstmt .

    $default  reduce using rule 8 (stmt)


State 46

    9 stmt: BREAK ';' .

    $default  reduce using rule 9 (stmt)


State 47

   10 stmt: CONTINUE ';' .

    $default  reduce using rule 10 (stmt)


State 48

   71 indexedelem: '{' . expr ':' expr '}'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 66
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 49

   15 expr: expr . op expr
   32 term: NOT expr .
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    ']'       reduce using rule 32 (term)
    ']'       [reduce using rule 60 (elist1)]
    ','       [reduce using rule 32 (term)]
    $default  reduce using rule 32 (term)

    op      go to state 85
    elist1  go to state 86


State 50

   15 expr: expr . op expr
   31 term: UMINUS expr .
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    ']'       reduce using rule 31 (term)
    ']'       [reduce using rule 60 (elist1)]
    ','       [reduce using rule 31 (term)]
    $default  reduce using rule 31 (term)

    op      go to state 85
    elist1  go to state 86


State 51

   53 call: '(' . funcdef ')' '(' elist ')'

    FUNCTION  shift, and go to state 10

    funcdef  go to state 102


State 52

   33 term: PLUSPLUS lvalue .
   48 member: lvalue . '.' ID
   49       | lvalue . '[' expr ']'
   52 call: lvalue . callsuffix

    DOUPLEDOT  shift, and go to state 89
    '.'        shift, and go to state 92

    $default  reduce using rule 33 (term)

    callsuffix  go to state 94
    normcall    go to state 95
    methodcall  go to state 96


State 53

   50 member: call . '.' ID call '[' expr ']'
   51 call: call . '(' elist ')'

    '('  shift, and go to state 97
    '.'  shift, and go to state 98


State 54

   35 term: MINUSMINUS lvalue .
   48 member: lvalue . '.' ID
   49       | lvalue . '[' expr ']'
   52 call: lvalue . callsuffix

    DOUPLEDOT  shift, and go to state 89
    '.'        shift, and go to state 92

    $default  reduce using rule 35 (term)

    callsuffix  go to state 94
    normcall    go to state 95
    methodcall  go to state 96


State 55

   45 lvalue: LOCAL ID .

    $default  reduce using rule 45 (lvalue)


State 56

   46 lvalue: SCOPEOP ID .

    $default  reduce using rule 46 (lvalue)


State 57

   76 funcdef1: ID .

    $default  reduce using rule 76 (funcdef1)


State 58

   74 funcdef: FUNCTION funcdef1 . '(' idlist ')' block

    '('  shift, and go to state 103


State 59

   86 ifstmt: IF '(' . expr ')' stmt ifstmt1

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 104
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 60

   89 whilestmt: WHILE '(' . expr ')' stmt

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 105
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 61

   90 forstmt: FOR '(' . elist ';' expr ';' elist ')' stmt

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 106
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 107
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 62

   15 expr: expr . op expr
   59 elist: expr . elist1
   93 returnstmt1: expr .

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    ']'       reduce using rule 60 (elist1)
    ']'       [reduce using rule 93 (returnstmt1)]
    $default  reduce using rule 93 (returnstmt1)

    op      go to state 85
    elist1  go to state 86


State 63

   91 returnstmt: RETURN returnstmt1 .

    $default  reduce using rule 91 (returnstmt)


State 64

   15 expr: expr . op expr
   30 term: '(' expr . ')'
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    ')'           shift, and go to state 108
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 65

   42 primary: '(' funcdef . ')'
   53 call: '(' funcdef . ')' '(' elist ')'

    ')'  shift, and go to state 109


State 66

   15 expr: expr . op expr
   59 elist: expr . elist1
   71 indexedelem: '{' expr . ':' expr '}'

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84
    ':'           shift, and go to state 110

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 67

    0 $accept: program $end .

    $default  accept


State 68

   73 block: stmt1 '}' .

    $default  reduce using rule 73 (block)


State 69

    3 stmt1: stmt stmt1 .
   73 block: stmt1 . '}'

    '}'  shift, and go to state 68

    '}'       [reduce using rule 3 (stmt1)]
    $default  reduce using rule 3 (stmt1)


State 70

   28 op: AND .

    $default  reduce using rule 28 (op)


State 71

   29 op: OR .

    $default  reduce using rule 29 (op)


State 72

   23 op: GREATEREQUAL .

    $default  reduce using rule 23 (op)


State 73

   25 op: LESSEQUAL .

    $default  reduce using rule 25 (op)


State 74

   26 op: EQUAL .

    $default  reduce using rule 26 (op)


State 75

   27 op: NOTEQUAL .

    $default  reduce using rule 27 (op)


State 76

   19 op: '*' .

    $default  reduce using rule 19 (op)


State 77

   20 op: '/' .

    $default  reduce using rule 20 (op)


State 78

   21 op: '%' .

    $default  reduce using rule 21 (op)


State 79

   17 op: '+' .

    $default  reduce using rule 17 (op)


State 80

   18 op: '-' .

    $default  reduce using rule 18 (op)


State 81

   22 op: '>' .

    $default  reduce using rule 22 (op)


State 82

   24 op: '<' .

    $default  reduce using rule 24 (op)


State 83

    4 stmt: expr ';' .

    $default  reduce using rule 4 (stmt)


State 84

   61 elist1: ',' . expr elist1

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 111
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 85

   15 expr: expr op . expr

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 112
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 86

   59 elist: expr elist1 .

    $default  reduce using rule 59 (elist)


State 87

   34 term: lvalue PLUSPLUS .

    $default  reduce using rule 34 (term)


State 88

   36 term: lvalue MINUSMINUS .

    $default  reduce using rule 36 (term)


State 89

   57 methodcall: DOUPLEDOT . ID '(' elist ')'

    ID  shift, and go to state 113


State 90

   56 normcall: '(' . elist ')'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 106
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 114
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 91

   49 member: lvalue '[' . expr ']'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 115
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 92

   48 member: lvalue '.' . ID

    ID  shift, and go to state 116


State 93

   38 assignexpr: lvalue '=' . expr

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 117
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 94

   52 call: lvalue callsuffix .

    $default  reduce using rule 52 (call)


State 95

   54 callsuffix: normcall .

    $default  reduce using rule 54 (callsuffix)


State 96

   55 callsuffix: methodcall .

    $default  reduce using rule 55 (callsuffix)


State 97

   51 call: call '(' . elist ')'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 106
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 118
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 98

   50 member: call '.' . ID call '[' expr ']'

    ID  shift, and go to state 119


State 99

   63 objectdef: objectdef1 ']' .

    $default  reduce using rule 63 (objectdef)


State 100

   70 indexed1: ',' . indexedelem indexed1

    '{'  shift, and go to state 48

    indexedelem  go to state 120


State 101

   68 indexed: indexedelem indexed1 .

    $default  reduce using rule 68 (indexed)


State 102

   53 call: '(' funcdef . ')' '(' elist ')'

    ')'  shift, and go to state 121


State 103

   74 funcdef: FUNCTION funcdef1 '(' . idlist ')' block

    ID  shift, and go to state 122

    $default  reduce using rule 82 (idlist)

    idlist  go to state 123


State 104

   15 expr: expr . op expr
   59 elist: expr . elist1
   86 ifstmt: IF '(' expr . ')' stmt ifstmt1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    ')'           shift, and go to state 124
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 105

   15 expr: expr . op expr
   59 elist: expr . elist1
   89 whilestmt: WHILE '(' expr . ')' stmt

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    ')'           shift, and go to state 125
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 106

   15 expr: expr . op expr
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 107

   65 objectdef1: elist .
   90 forstmt: FOR '(' elist . ';' expr ';' elist ')' stmt

    ';'  shift, and go to state 126

    $default  reduce using rule 65 (objectdef1)


State 108

   30 term: '(' expr ')' .

    $default  reduce using rule 30 (term)


State 109

   42 primary: '(' funcdef ')' .
   53 call: '(' funcdef ')' . '(' elist ')'

    $default  reduce using rule 42 (primary)


State 110

   71 indexedelem: '{' expr ':' . expr '}'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 128
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 111

   15 expr: expr . op expr
   59 elist: expr . elist1
   61 elist1: ',' expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 129


State 112

   15 expr: expr . op expr
   15     | expr op expr .
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    AND           [reduce using rule 15 (expr)]
    OR            [reduce using rule 15 (expr)]
    GREATEREQUAL  [reduce using rule 15 (expr)]
    LESSEQUAL     [reduce using rule 15 (expr)]
    EQUAL         [reduce using rule 15 (expr)]
    NOTEQUAL      [reduce using rule 15 (expr)]
    ']'           reduce using rule 15 (expr)
    ']'           [reduce using rule 60 (elist1)]
    '*'           [reduce using rule 15 (expr)]
    '/'           [reduce using rule 15 (expr)]
    '%'           [reduce using rule 15 (expr)]
    '+'           [reduce using rule 15 (expr)]
    '-'           [reduce using rule 15 (expr)]
    '>'           [reduce using rule 15 (expr)]
    '<'           [reduce using rule 15 (expr)]
    ','           [reduce using rule 15 (expr)]
    $default      reduce using rule 15 (expr)

    op      go to state 85
    elist1  go to state 86


State 113

   57 methodcall: DOUPLEDOT ID . '(' elist ')'

    '('  shift, and go to state 130


State 114

   56 normcall: '(' elist . ')'
   65 objectdef1: elist .

    ')'  shift, and go to state 131

    $default  reduce using rule 65 (objectdef1)


State 115

   15 expr: expr . op expr
   49 member: lvalue '[' expr . ']'
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    ']'           shift, and go to state 132
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    ']'  [reduce using rule 60 (elist1)]

    op      go to state 85
    elist1  go to state 86


State 116

   48 member: lvalue '.' ID .

    $default  reduce using rule 48 (member)


State 117

   15 expr: expr . op expr
   38 assignexpr: lvalue '=' expr .
   59 elist: expr . elist1

    ','  shift, and go to state 84

    ']'       reduce using rule 38 (assignexpr)
    ']'       [reduce using rule 60 (elist1)]
    ','       [reduce using rule 38 (assignexpr)]
    $default  reduce using rule 38 (assignexpr)

    op      go to state 85
    elist1  go to state 86


State 118

   51 call: call '(' elist . ')'
   65 objectdef1: elist .

    ')'  shift, and go to state 133

    $default  reduce using rule 65 (objectdef1)


State 119

   50 member: call '.' ID . call '[' expr ']'

    ID       shift, and go to state 1
    LOCAL    shift, and go to state 8
    SCOPEOP  shift, and go to state 9
    '('      shift, and go to state 51

    lvalue  go to state 134
    member  go to state 32
    call    go to state 135


State 120

   70 indexed1: ',' indexedelem . indexed1

    ','  shift, and go to state 100

    $default  reduce using rule 69 (indexed1)

    indexed1  go to state 136


State 121

   53 call: '(' funcdef ')' . '(' elist ')'

    '('  shift, and go to state 127


State 122

   83 idlist: ID . idlist1

    ','  shift, and go to state 137

    $default  reduce using rule 84 (idlist1)

    idlist1  go to state 138


State 123

   74 funcdef: FUNCTION funcdef1 '(' idlist . ')' block

    ')'  shift, and go to state 139


State 124

   86 ifstmt: IF '(' expr ')' . stmt ifstmt1

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 2 (stmt1)

    stmt1        go to state 140
    stmt         go to state 141
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 125

   89 whilestmt: WHILE '(' expr ')' . stmt

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 2 (stmt1)

    stmt1        go to state 140
    stmt         go to state 142
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 126

   90 forstmt: FOR '(' elist ';' . expr ';' elist ')' stmt

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 143
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 127

   53 call: '(' funcdef ')' '(' . elist ')'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 106
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 144
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 128

   15 expr: expr . op expr
   59 elist: expr . elist1
   71 indexedelem: '{' expr ':' expr . '}'

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84
    '}'           shift, and go to state 145

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 129

   59 elist: expr elist1 .
   61 elist1: ',' expr elist1 .

    ']'       reduce using rule 59 (elist)
    ']'       [reduce using rule 61 (elist1)]
    $default  reduce using rule 61 (elist1)


State 130

   57 methodcall: DOUPLEDOT ID '(' . elist ')'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 106
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 146
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 131

   56 normcall: '(' elist ')' .

    $default  reduce using rule 56 (normcall)


State 132

   49 member: lvalue '[' expr ']' .

    $default  reduce using rule 49 (member)


State 133

   51 call: call '(' elist ')' .

    $default  reduce using rule 51 (call)


State 134

   48 member: lvalue . '.' ID
   49       | lvalue . '[' expr ']'
   52 call: lvalue . callsuffix

    DOUPLEDOT  shift, and go to state 89
    '('        shift, and go to state 90
    '['        shift, and go to state 91
    '.'        shift, and go to state 92

    callsuffix  go to state 94
    normcall    go to state 95
    methodcall  go to state 96


State 135

   50 member: call . '.' ID call '[' expr ']'
   50       | call '.' ID call . '[' expr ']'
   51 call: call . '(' elist ')'

    '('  shift, and go to state 97
    '['  shift, and go to state 147
    '.'  shift, and go to state 98


State 136

   70 indexed1: ',' indexedelem indexed1 .

    $default  reduce using rule 70 (indexed1)


State 137

   85 idlist1: ',' . ID idlist1

    ID  shift, and go to state 148


State 138

   83 idlist: ID idlist1 .

    $default  reduce using rule 83 (idlist)


State 139

   74 funcdef: FUNCTION funcdef1 '(' idlist ')' . block

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 2 (stmt1)

    stmt1        go to state 140
    stmt         go to state 26
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 149
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 140

   73 block: stmt1 . '}'

    '}'  shift, and go to state 68


State 141

    3 stmt1: stmt . stmt1
   86 ifstmt: IF '(' expr ')' stmt . ifstmt1

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    ELSE        shift, and go to state 150
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    $end        reduce using rule 87 (ifstmt1)
    ID          [reduce using rule 87 (ifstmt1)]
    BREAK       [reduce using rule 87 (ifstmt1)]
    CONTINUE    [reduce using rule 87 (ifstmt1)]
    NOT         [reduce using rule 87 (ifstmt1)]
    UMINUS      [reduce using rule 87 (ifstmt1)]
    PLUSPLUS    [reduce using rule 87 (ifstmt1)]
    MINUSMINUS  [reduce using rule 87 (ifstmt1)]
    LOCAL       [reduce using rule 87 (ifstmt1)]
    SCOPEOP     [reduce using rule 87 (ifstmt1)]
    FUNCTION    [reduce using rule 87 (ifstmt1)]
    NUMBER      [reduce using rule 87 (ifstmt1)]
    STRING      [reduce using rule 87 (ifstmt1)]
    NIL         [reduce using rule 87 (ifstmt1)]
    TRUE        [reduce using rule 87 (ifstmt1)]
    FALSE       [reduce using rule 87 (ifstmt1)]
    IF          [reduce using rule 87 (ifstmt1)]
    ELSE        [reduce using rule 87 (ifstmt1)]
    WHILE       [reduce using rule 87 (ifstmt1)]
    FOR         [reduce using rule 87 (ifstmt1)]
    RETURN      [reduce using rule 87 (ifstmt1)]
    '('         [reduce using rule 87 (ifstmt1)]
    '['         [reduce using rule 87 (ifstmt1)]
    ']'         reduce using rule 58 (elist)
    ']'         [reduce using rule 64 (objectdef1)]
    ']'         [reduce using rule 67 (indexed)]
    ']'         [reduce using rule 87 (ifstmt1)]
    ';'         [reduce using rule 87 (ifstmt1)]
    '{'         [reduce using rule 87 (ifstmt1)]
    '}'         reduce using rule 2 (stmt1)
    '}'         [reduce using rule 87 (ifstmt1)]
    $default    reduce using rule 2 (stmt1)

    stmt1        go to state 69
    stmt         go to state 26
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    ifstmt1      go to state 151
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 142

    3 stmt1: stmt . stmt1
   89 whilestmt: WHILE '(' expr ')' stmt .

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ID        [reduce using rule 89 (whilestmt)]
    BREAK     [reduce using rule 89 (whilestmt)]
    CONTINUE  [reduce using rule 89 (whilestmt)]
    LOCAL     [reduce using rule 89 (whilestmt)]
    SCOPEOP   [reduce using rule 89 (whilestmt)]
    FUNCTION  [reduce using rule 89 (whilestmt)]
    NUMBER    [reduce using rule 89 (whilestmt)]
    STRING    [reduce using rule 89 (whilestmt)]
    NIL       [reduce using rule 89 (whilestmt)]
    TRUE      [reduce using rule 89 (whilestmt)]
    FALSE     [reduce using rule 89 (whilestmt)]
    IF        [reduce using rule 89 (whilestmt)]
    WHILE     [reduce using rule 89 (whilestmt)]
    FOR       [reduce using rule 89 (whilestmt)]
    RETURN    [reduce using rule 89 (whilestmt)]
    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    ']'       [reduce using rule 89 (whilestmt)]
    ';'       [reduce using rule 89 (whilestmt)]
    '{'       [reduce using rule 89 (whilestmt)]
    '}'       reduce using rule 2 (stmt1)
    '}'       [reduce using rule 89 (whilestmt)]
    $default  reduce using rule 89 (whilestmt)

    stmt1        go to state 69
    stmt         go to state 26
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 143

   15 expr: expr . op expr
   59 elist: expr . elist1
   90 forstmt: FOR '(' elist ';' expr . ';' elist ')' stmt

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ';'           shift, and go to state 152
    ','           shift, and go to state 84

    $default  reduce using rule 60 (elist1)

    op      go to state 85
    elist1  go to state 86


State 144

   53 call: '(' funcdef ')' '(' elist . ')'
   65 objectdef1: elist .

    ')'  shift, and go to state 153

    $default  reduce using rule 65 (objectdef1)


State 145

   71 indexedelem: '{' expr ':' expr '}' .

    $default  reduce using rule 71 (indexedelem)


State 146

   57 methodcall: DOUPLEDOT ID '(' elist . ')'
   65 objectdef1: elist .

    ')'  shift, and go to state 154

    $default  reduce using rule 65 (objectdef1)


State 147

   50 member: call '.' ID call '[' . expr ']'

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 155
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 148

   85 idlist1: ',' ID . idlist1

    ','  shift, and go to state 137

    $default  reduce using rule 84 (idlist1)

    idlist1  go to state 156


State 149

   11 stmt: block .
   74 funcdef: FUNCTION funcdef1 '(' idlist ')' block .

    $end        reduce using rule 74 (funcdef)
    ID          reduce using rule 11 (stmt)
    ID          [reduce using rule 74 (funcdef)]
    BREAK       reduce using rule 11 (stmt)
    BREAK       [reduce using rule 74 (funcdef)]
    CONTINUE    reduce using rule 11 (stmt)
    CONTINUE    [reduce using rule 74 (funcdef)]
    NOT         reduce using rule 11 (stmt)
    NOT         [reduce using rule 74 (funcdef)]
    UMINUS      reduce using rule 11 (stmt)
    UMINUS      [reduce using rule 74 (funcdef)]
    PLUSPLUS    reduce using rule 11 (stmt)
    PLUSPLUS    [reduce using rule 74 (funcdef)]
    MINUSMINUS  reduce using rule 11 (stmt)
    MINUSMINUS  [reduce using rule 74 (funcdef)]
    LOCAL       reduce using rule 11 (stmt)
    LOCAL       [reduce using rule 74 (funcdef)]
    SCOPEOP     reduce using rule 11 (stmt)
    SCOPEOP     [reduce using rule 74 (funcdef)]
    FUNCTION    reduce using rule 11 (stmt)
    FUNCTION    [reduce using rule 74 (funcdef)]
    NUMBER      reduce using rule 11 (stmt)
    NUMBER      [reduce using rule 74 (funcdef)]
    STRING      reduce using rule 11 (stmt)
    STRING      [reduce using rule 74 (funcdef)]
    NIL         reduce using rule 11 (stmt)
    NIL         [reduce using rule 74 (funcdef)]
    TRUE        reduce using rule 11 (stmt)
    TRUE        [reduce using rule 74 (funcdef)]
    FALSE       reduce using rule 11 (stmt)
    FALSE       [reduce using rule 74 (funcdef)]
    IF          reduce using rule 11 (stmt)
    IF          [reduce using rule 74 (funcdef)]
    ELSE        reduce using rule 74 (funcdef)
    WHILE       reduce using rule 11 (stmt)
    WHILE       [reduce using rule 74 (funcdef)]
    FOR         reduce using rule 11 (stmt)
    FOR         [reduce using rule 74 (funcdef)]
    RETURN      reduce using rule 11 (stmt)
    RETURN      [reduce using rule 74 (funcdef)]
    '('         reduce using rule 11 (stmt)
    '('         [reduce using rule 74 (funcdef)]
    ')'         reduce using rule 74 (funcdef)
    '['         reduce using rule 11 (stmt)
    '['         [reduce using rule 74 (funcdef)]
    ']'         reduce using rule 11 (stmt)
    ']'         [reduce using rule 74 (funcdef)]
    ';'         reduce using rule 11 (stmt)
    ';'         [reduce using rule 74 (funcdef)]
    '{'         reduce using rule 11 (stmt)
    '{'         [reduce using rule 74 (funcdef)]
    '}'         reduce using rule 11 (stmt)
    '}'         [reduce using rule 74 (funcdef)]
    $default    reduce using rule 11 (stmt)


State 150

   88 ifstmt1: ELSE . stmt

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 2 (stmt1)

    stmt1        go to state 140
    stmt         go to state 157
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 151

   86 ifstmt: IF '(' expr ')' stmt ifstmt1 .

    $default  reduce using rule 86 (ifstmt)


State 152

   90 forstmt: FOR '(' elist ';' expr ';' . elist ')' stmt

    ID          shift, and go to state 1
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    '{'         shift, and go to state 48

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 58 (elist)

    expr         go to state 106
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 158
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    const        go to state 41


State 153

   53 call: '(' funcdef ')' '(' elist ')' .

    $default  reduce using rule 53 (call)


State 154

   57 methodcall: DOUPLEDOT ID '(' elist ')' .

    $default  reduce using rule 57 (methodcall)


State 155

   15 expr: expr . op expr
   50 member: call '.' ID call '[' expr . ']'
   59 elist: expr . elist1

    AND           shift, and go to state 70
    OR            shift, and go to state 71
    GREATEREQUAL  shift, and go to state 72
    LESSEQUAL     shift, and go to state 73
    EQUAL         shift, and go to state 74
    NOTEQUAL      shift, and go to state 75
    ']'           shift, and go to state 159
    '*'           shift, and go to state 76
    '/'           shift, and go to state 77
    '%'           shift, and go to state 78
    '+'           shift, and go to state 79
    '-'           shift, and go to state 80
    '>'           shift, and go to state 81
    '<'           shift, and go to state 82
    ','           shift, and go to state 84

    ']'  [reduce using rule 60 (elist1)]

    op      go to state 85
    elist1  go to state 86


State 156

   85 idlist1: ',' ID idlist1 .

    $default  reduce using rule 85 (idlist1)


State 157

    3 stmt1: stmt . stmt1
   88 ifstmt1: ELSE stmt .

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ID          [reduce using rule 88 (ifstmt1)]
    BREAK       [reduce using rule 88 (ifstmt1)]
    CONTINUE    [reduce using rule 88 (ifstmt1)]
    NOT         [reduce using rule 88 (ifstmt1)]
    UMINUS      [reduce using rule 88 (ifstmt1)]
    PLUSPLUS    [reduce using rule 88 (ifstmt1)]
    MINUSMINUS  [reduce using rule 88 (ifstmt1)]
    LOCAL       [reduce using rule 88 (ifstmt1)]
    SCOPEOP     [reduce using rule 88 (ifstmt1)]
    FUNCTION    [reduce using rule 88 (ifstmt1)]
    NUMBER      [reduce using rule 88 (ifstmt1)]
    STRING      [reduce using rule 88 (ifstmt1)]
    NIL         [reduce using rule 88 (ifstmt1)]
    TRUE        [reduce using rule 88 (ifstmt1)]
    FALSE       [reduce using rule 88 (ifstmt1)]
    IF          [reduce using rule 88 (ifstmt1)]
    WHILE       [reduce using rule 88 (ifstmt1)]
    FOR         [reduce using rule 88 (ifstmt1)]
    RETURN      [reduce using rule 88 (ifstmt1)]
    '('         [reduce using rule 88 (ifstmt1)]
    '['         [reduce using rule 88 (ifstmt1)]
    ']'         reduce using rule 58 (elist)
    ']'         [reduce using rule 64 (objectdef1)]
    ']'         [reduce using rule 67 (indexed)]
    ']'         [reduce using rule 88 (ifstmt1)]
    ';'         [reduce using rule 88 (ifstmt1)]
    '{'         [reduce using rule 88 (ifstmt1)]
    '}'         reduce using rule 2 (stmt1)
    '}'         [reduce using rule 88 (ifstmt1)]
    $default    reduce using rule 88 (ifstmt1)

    stmt1        go to state 69
    stmt         go to state 26
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 158

   65 objectdef1: elist .
   90 forstmt: FOR '(' elist ';' expr ';' elist . ')' stmt

    ')'  shift, and go to state 160

    $default  reduce using rule 65 (objectdef1)


State 159

   50 member: call '.' ID call '[' expr ']' .

    $default  reduce using rule 50 (member)


State 160

   90 forstmt: FOR '(' elist ';' expr ';' elist ')' . stmt

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '('         shift, and go to state 20
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    $default  reduce using rule 2 (stmt1)

    stmt1        go to state 140
    stmt         go to state 161
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45


State 161

    3 stmt1: stmt . stmt1
   90 forstmt: FOR '(' elist ';' expr ';' elist ')' stmt .

    ID          shift, and go to state 1
    BREAK       shift, and go to state 2
    CONTINUE    shift, and go to state 3
    NOT         shift, and go to state 4
    UMINUS      shift, and go to state 5
    PLUSPLUS    shift, and go to state 6
    MINUSMINUS  shift, and go to state 7
    LOCAL       shift, and go to state 8
    SCOPEOP     shift, and go to state 9
    FUNCTION    shift, and go to state 10
    NUMBER      shift, and go to state 11
    STRING      shift, and go to state 12
    NIL         shift, and go to state 13
    TRUE        shift, and go to state 14
    FALSE       shift, and go to state 15
    IF          shift, and go to state 16
    WHILE       shift, and go to state 17
    FOR         shift, and go to state 18
    RETURN      shift, and go to state 19
    '['         shift, and go to state 21
    ';'         shift, and go to state 22
    '{'         shift, and go to state 23

    ID        [reduce using rule 90 (forstmt)]
    BREAK     [reduce using rule 90 (forstmt)]
    CONTINUE  [reduce using rule 90 (forstmt)]
    LOCAL     [reduce using rule 90 (forstmt)]
    SCOPEOP   [reduce using rule 90 (forstmt)]
    FUNCTION  [reduce using rule 90 (forstmt)]
    NUMBER    [reduce using rule 90 (forstmt)]
    STRING    [reduce using rule 90 (forstmt)]
    NIL       [reduce using rule 90 (forstmt)]
    TRUE      [reduce using rule 90 (forstmt)]
    FALSE     [reduce using rule 90 (forstmt)]
    IF        [reduce using rule 90 (forstmt)]
    WHILE     [reduce using rule 90 (forstmt)]
    FOR       [reduce using rule 90 (forstmt)]
    RETURN    [reduce using rule 90 (forstmt)]
    ']'       reduce using rule 58 (elist)
    ']'       [reduce using rule 64 (objectdef1)]
    ']'       [reduce using rule 67 (indexed)]
    ']'       [reduce using rule 90 (forstmt)]
    ';'       [reduce using rule 90 (forstmt)]
    '{'       [reduce using rule 90 (forstmt)]
    '}'       reduce using rule 2 (stmt1)
    '}'       [reduce using rule 90 (forstmt)]
    $default  reduce using rule 90 (forstmt)

    stmt1        go to state 69
    stmt         go to state 26
    expr         go to state 27
    term         go to state 28
    assignexpr   go to state 29
    primary      go to state 30
    lvalue       go to state 31
    member       go to state 32
    call         go to state 33
    elist        go to state 34
    objectdef    go to state 35
    objectdef1   go to state 36
    indexed      go to state 37
    indexedelem  go to state 38
    block        go to state 39
    funcdef      go to state 40
    const        go to state 41
    ifstmt       go to state 42
    whilestmt    go to state 43
    forstmt      go to state 44
    returnstmt   go to state 45
